
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="theme-color" content="#1a1a1a"/>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache">
    <meta http-equiv="Pragma" content="no-cache">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song Search</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://kit.fontawesome.com/e54d0c3ef1.js" crossorigin="anonymous"></script>
    <script>
        // Configuration - Replace with your actual API endpoints and tokens
        const HAURL = 'http://homeassistant.local:8100'; // Your internal HA URL IP
        let API_TOKEN = null // Will be set after loading
        const QUEUEWEBHOOK = 'jukebox-notify-of-queued-song-J57yI9fxbxbmzqt7qynml0qJ'; // required to coordinate Jukebox Queue mode.
        const MEDIA_PLAYER = "media_player.speakers_schuur_2"; // Your speaker entity to play the tuuuuuuunes
        const MUSIC_ASSISTANT_CONFIG = "01JVZHQ6Z4ANEDC9NE4HHA2RJ9"; // Your MA config ID
 </script>
    <style>
    
    #placeholderImage:not([style*="display: none"]) ~ .results-table thead {
        display: none;
    }

    #qrcode {
        padding: 15px;
        border-radius: 8px;
        backdrop-filter: blur(5px);
        color: #fff;
    }
    
    #qrcode img {
        display: block;
        margin: 0 auto;
    }

    #page {
        /*background: rgba(255, 255, 255, 0.98);*/
        border-radius: 8px;
        padding: 20px;
        
        backdrop-filter: blur(5px);
        position: relative;
    }
    th{
        color:#ddd
    }

    #page, #accessDenied {
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }

    body.loaded #page,
    body.loaded #accessDenied {
        visibility: visible;
        opacity: 1;
    }

    #accessDenied {
        display: none;
        text-align: center;
        padding: 20px;
        color: #ffffff;
        border-radius: 4px;
        margin: 20px auto;
        backdrop-filter: blur(10px);
    }

    body {
        font-family: Arial, sans-serif;
        max-width: 1000px;
        margin: 20px auto;
        padding: 0 20px;
        box-sizing: border-box;
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
        --bg-image: url('bg.jpg');
    }

    body::before {
        content: '';
        position: fixed;
        top: -20%;
        left: -20%;
        width: 150%;
        height: 150%;
        background-image: var(--bg-image);
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        filter: blur(60px) brightness(0.4);
        z-index: -1;
        transform: translate3d(0, 0, 0);
        transition: background-image 1s ease-in-out;
        will-change: background-image;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
    }

    /* Add this in the <style> section */
    .loader {
        display: none;
        width: 30px;
        height: 30px;
        position: absolute;
        right: 45px;
        top: 40%;
        transform: translateY(-50%);
    }

    .search-container {
        margin-bottom: 20px;
        display: flex;
        flex-wrap: nowrap;
        gap: 10px;
        position: relative;
        align-items: center;
    }

    .search-input-container {
        position: relative;
        flex: 1;
        min-width: 0; /* Allow container to shrink */
    }
    
    textarea:focus, input:focus{
        outline: none;
    }
    
    #searchInput {
        width: 100%;
        padding: 10px;
        padding-right: 40px;
        padding-left: 35px; /* Make room for the icon */
        border-style: solid;
        font-size: 16px;
        color:white;
        font-weight: 500;
        box-sizing: border-box;
        border-width: 0px 0px 2px 0px;
        font-family: system-ui;
        border-color: darkgrey;
        background-color: rgb(198 197 197 / 10%);
        padding-right: 70px;
    }

    #searchInput.loading {
        background: url(http://www.xiconeditor.com/image/icons/loading.gif) no-repeat right center;
    }

    .clear-button {
        display: none;
        position: absolute;
        right: 20px; /* Position it to the left of the loader */
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        padding: 0;
        font-size: 14px;
        z-index: 2;
    }

    .clear-button:hover {
        color: #999;
    }
    
    .results-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        text-align: center;
        /*background: rgba(255, 255, 255, 0.95);*/
        border-radius: 8px;
        overflow: hidden;
    }

    .results-table tr {
        margin-bottom: 20px;
        display: table-row;
        background-color: rgba(255, 255, 255, 0.05);
    }

    .results-table td {
        padding: 20px;
    }

    .album-cover {
        width: 100%;
        max-width: 250px;
        height: auto;
        aspect-ratio: 1;
        object-fit: cover;
        border-radius: 4px;
    }
    
    .placeholder-art {
        width: 250px;
        max-width: 250px;
        margin-left: 20px;
        aspect-ratio: 1;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 1.1em;
        text-align: center;
    }

    .placeholder-art i {
        font-size: 3em;
        margin-bottom: 10px;
        opacity: 0.8;
    }

    #searchButton {
        border: 1px solid #373497;
        background-color: #246fe0;
        color: white;
        text-align: center;
        border-radius: 4px;
        padding: 10px;
    }

    .play-button {
        margin-top: 10px;
        background-color: #3d7393;
        color: #ffffff;
        text-align: center;
        border:none;
        padding: 10px;
        font-family: system-ui;
        transition: all 0.3s ease;
        font-weight: 700;
    }

    /* Add new responsive styles */
    @media screen and (max-width: 768px) {
        body {
            padding: 0 10px;
        }

        .results-table {
            display: table;
            overflow-x: auto;
            text-align: center;
        }

        .results-table thead {
            display: none;
        }

        .results-table tbody tr {
            display: flex;
            flex-direction: column;
            
            padding-top: 10px;
            margin-bottom: 20px;
        }

        .results-table td {
            display: block;
            padding: 8px 0;
            border: none;
        }

        .results-table td:nth-child(2) {
            display: flex;
            flex-direction: column;  /* Force vertical stacking */
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        .results-table td:nth-child(2) div {
            width: 100%;
            text-align: center;
        }
        .results-table td:nth-child(2)::before {
            content: "";
            font-weight: bold;
            clear:both;
        }

        .results-table td:nth-child(3) {
            /* display: none; */
            width: 100%;
            padding-top: 10px;
        }

        .album-cover {
            max-width: 250px;
            margin: 0 auto;
        }

        .placeholder-art {
            width: 250px;
            max-width: 250px;
            aspect-ratio: 1;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 1.1em;
            text-align: center;
            margin: 0 auto;
        }

        .play-button {
           width: 100%;
            margin-top: 10px;
            background-color: #3d7393;
            color: #ffffff;
            text-align: center;
            border:none;
            padding: 10px;
            font-family: system-ui;
        }

        
    }

    @media screen and (max-width: 480px) {
        .search-container {
            flex-direction: row;
        }
        .loader {
            right: 10px; /* Adjust for mobile when search button stacks */
        }
        
        #searchInput {
            padding-right: 35px;
        }

        #searchButton {
            white-space: nowrap; /* Prevent button text from wrapping */
        }
    }
    
    h1,h2 {
      font-weight: 700;
      margin: 1em 0;
      font-family: system-ui;
      padding: 0.7em 0.7em;
      font-size: 18px;
      color: #fff;
      border: solid 20px;
      border-color: rgb(198 197 197 / 20%);
    }

    h1 { 
        font-size: 3.5em; 
    }

    h2 {
      color: #e8e6e6;
      font-size: 2em;
    }

    </style>
</head>
<body>
    <div id="accessDenied">
        <h2>Queuing Closed.</h2>
        <p>Sorry, the jukebox is currently disabled. Until next time!</p>
    </div>

    <div id="page">
        <div class="search-container">
            <div style="position: relative; flex: 1;">
                <div style="position: relative; display: flex; align-items: center;">
                    <i class="fa-solid fa-magnifying-glass" style="position: absolute; left: 10px; color: #666;"></i>
                    <input type="text" id="searchInput" placeholder="Search song title..." autofocus style="padding-left: 35px;">
                    <button class="clear-button" id="clearSearch">
                        <i style="font-size: large;" class="fa-solid fa-xmark"></i>
                    </button>
                    <img src="https://i.gifer.com/6oa.gif" alt="Loading..." class="loader" id="searchLoader">
                </div>
            </div>
            <button style="display: none;" id="searchButton">Search</button>
        </div>
        <div id="placeholderImage">
            <link href="https://fonts.googleapis.com/css?family=Raleway:200,100,400" rel="stylesheet" type="text/css" />
            <h1>
              <span
                 class="txt-rotate"
                 data-period="1000"
                 data-rotate='[ "Search.", "Queue.", "Party." ]'>
              </span>
            </h1>
            <p style="margin-top: 10px; color: #666;"></p>
            <div id="qrcode" style="text-align: center; margin-top: 20px;"></div>
        </div>
        <table id="songsTable" class="results-table">
            <thead>
                <tr>
                    <th>Album</th>
                    <th>Track</th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="songResults">
            </tbody>
        </table>
    </div>

    <script>
        async function getApiToken() {
            try {
                // Add timestamp to URL to prevent caching
                const timestamp = new Date().getTime();
                const response = await fetch(`jukeboxtoken.key?_=${timestamp}`, {
                    // Add cache control headers
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load API token');
                }
                const token = await response.text();
                return token.trim(); // Remove any whitespace
            } catch (error) {
                console.error('Error loading API token:', error);
                //alert('Failed to load authentication token. Please check if jukeboxtoken.key exists.');
                return null;
            }
        }


        // API Endpoints
        const CHECK_API_ENDPOINT = HAURL+'/api/states/input_boolean.songrequestaccess';
        const SEARCH_API_ENDPOINT = HAURL+'/api/services/music_assistant/search?return_response';
        const PLAY_API_ENDPOINT = HAURL+'/api/services/music_assistant/play_media';
        const NOTIFY_API_ENDPOINT = HAURL+'/api/webhook/'+QUEUEWEBHOOK;
        const CHECK_QUEUE_MODE_ENDPOINT = HAURL+'/api/states/input_boolean.jukebox_queue';
        
        function FocusOnInput() {
            var element = document.getElementById('searchInput');
            element.focus();
            setTimeout(function () { element.focus(); }, 2);
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', async () => {
            
            API_TOKEN = await getApiToken();

            if (!API_TOKEN) {
                document.getElementById('page').style.display = 'none';
                document.getElementById('accessDenied').style.display = 'block';
                document.getElementById('accessDenied').innerHTML = `
                    <h2>Queueing Closed</h2>
                    <p>Sorry, the jukebox is currently disabled. Until next time!</p>
                `;
            } else {
                document.getElementById('page').style.display = 'block';
                document.getElementById('accessDenied').style.display = 'none';
            }

            // Add loaded class to body to trigger fade in
            document.body.classList.add('loaded');
    

            //const AppEnabled = await checkService();
            startServiceCheck();

            let searchTimeout;
            
            document.getElementById('searchInput').addEventListener('input', function(e) {
                
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    searchSongs();
                }, 700); // 700ms = .7 seconds
            });

            document.getElementById('searchButton').addEventListener('click', searchSongs);
            document.getElementById('searchInput').addEventListener('keypress', function(e) {
                const loader = document.getElementById('searchLoader');
                loader.style.display = 'block'; // Show loader
                const searchbtn = document.getElementById('searchButton');
                searchbtn.textContent = 'Searching...';
                searchbtn.style.backgroundColor = '#cccccc';
                searchbtn.style.borderColor = '#cccccc';
                searchbtn.disabled = true;
                if (e.key === 'Enter') {
                    clearTimeout(searchTimeout);
                    searchSongs();
                    
                }
            
            });
            
            const searchInput = document.getElementById('searchInput');
            const clearButton = document.getElementById('clearSearch');

            // Show/hide clear button based on input content
            searchInput.addEventListener('input', function() {
                clearButton.style.display = this.value ? 'block' : 'none';
            });

            // Clear input when button is clicked
            clearButton.addEventListener('click', function() {
                searchInput.value = '';
                clearButton.style.display = 'none';
                searchInput.focus();
                
                // Reset search results
                const placeholder = document.getElementById('placeholderImage');
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                document.getElementById('songResults').innerHTML = '';
            });
        });

        async function searchSongs() {

            // Hide placeholder image when search starts
            const placeholder = document.getElementById('placeholderImage');
            const searchTerm = document.getElementById('searchInput').value.trim();
            const searchbtn = document.getElementById('searchButton');
            const loader = document.getElementById('searchLoader');

            // Return early if search term is empty
            if (!searchTerm) {
                searchbtn.style.backgroundColor = '#cccccc';
                searchbtn.style.borderColor = '#cccccc';
                searchbtn.disabled = true;
                setTimeout(() => {
                    searchbtn.style.backgroundColor = '#246fe0';
                    searchbtn.style.borderColor = '#373497';
                    searchbtn.disabled = false;
                }, 1000);
                return;
            }

            loader.style.display = 'block'; // Show loader
            searchbtn.textContent = 'Searching...'; 
            searchbtn.disabled = true;
            searchbtn.style.backgroundColor = '#cccccc';
            searchbtn.style.borderColor = '#cccccc';

            try {

                const searchRequest = {
                    limit: "10",
                    library_only: "false",
                    config_entry_id: MUSIC_ASSISTANT_CONFIG,
                    name: searchTerm,
                    //media_type: "track"
                };

                const response = await fetch(SEARCH_API_ENDPOINT, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Authorization': `Bearer ${API_TOKEN}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(searchRequest)
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
                const data = await response.json();
                const tracks = data.service_response.tracks;
                displaySongs(tracks);

            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while searching for songs');
            } finally {
                loader.style.display = 'none'; // Hide loader
                searchbtn.textContent = 'Search'; 
                searchbtn.disabled = false;
                searchbtn.style.backgroundColor = '#246fe0';
                searchbtn.style.borderColor = '#373497';
                
            }
        }

        function displaySongs(tracks) {
            const songResults = document.getElementById('songResults');
            songResults.innerHTML = '';

            if (!tracks || tracks.length === 0) {
                const row = songResults.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 4;
                cell.textContent = 'No songs found';
                cell.style.color = '#fff'
                cell.style.fontWeight = 'bold';
                cell.style.fontSize = '1.2em';
                return;
            }

            // Preload the background image
            if (tracks[0] && tracks[0].image) {
                const img = new Image();
                img.onload = function() {
                    // Update background only after image is loaded
                    document.body.style.setProperty('--bg-image', `url('${tracks[0].image}')`);
                };
                img.src = tracks[0].image;
            }

            // Display each track in a row
            tracks.forEach(track => {
                const row = songResults.insertRow();
                
                // Album cover cell
                const coverCell = row.insertCell();
                if (track.image) {
                    const coverImg = document.createElement('img');
                    coverImg.src = track.image;
                    coverImg.alt = 'Album Cover';
                    coverImg.className = 'album-cover';
                    coverCell.appendChild(coverImg);
                    
                } else {
                    const placeholderDiv = document.createElement('div');
                    placeholderDiv.className = 'placeholder-art';
                    const icon = document.createElement('i');
                    icon.className = 'fa-solid fa-music';
                    const artistDiv = document.createElement('div');
                    artistDiv.textContent = track.artists.map(artist => artist.name).join(', ');
                    placeholderDiv.appendChild(icon);
                    placeholderDiv.appendChild(artistDiv);
                    coverCell.appendChild(placeholderDiv);
                }

                // Combined track and artist cell
                const detailsCell = row.insertCell();
                const trackDiv = document.createElement('div');
                trackDiv.textContent = track.name;
                trackDiv.style.fontWeight = 'bold';
                trackDiv.style.marginBottom = '5px';
                trackDiv.style.color = '#fff';

                const artistDiv = document.createElement('div');
                artistDiv.textContent = track.artists.map(artist => artist.name).join(', ');
                artistDiv.style.color = '#afaeae';
                artistDiv.style.fontSize = '0.9em';
                
                detailsCell.appendChild(trackDiv);
                detailsCell.appendChild(artistDiv);

                // Play button cell
                const actionCell = row.insertCell();
                const playButton = document.createElement('button');
                playButton.innerHTML = "<i class='fa-solid fa-plus'></i> Add to Queue";
                playButton.className = 'play-button';
                playButton.onclick = () => playSong(track, playButton);
                actionCell.appendChild(playButton);
            });

        }
        
        async function checkQueueMode() {
            try {

                const response = await fetch(CHECK_QUEUE_MODE_ENDPOINT, {
                    method: 'GET',
                    credentials: "same-origin",
                    headers: {
                        'Authorization': `Bearer ${API_TOKEN}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const result = await response.json();
                return result.state === 'on' ? 'add' : 'replace_next';

            } catch (error) {
                console.error('Error checking queue mode:', error);
                return 'next'; // Default to 'next' if there's an error
            }
        }

        async function playSong(track, playButton) {
            try {
                const queueMode = await checkQueueMode();
                
                const playRequest = {
                    enqueue: queueMode,
                    media_id: track.uri,
                    entity_id: MEDIA_PLAYER
                };

                const response = await fetch(PLAY_API_ENDPOINT, {
                    method: 'POST',
                    credentials: "same-origin",
                    headers: {
                        'Authorization': `Bearer ${API_TOKEN}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(playRequest)
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                    // Update button state after successful request
                    playButton.textContent = 'Queued';
                    playButton.disabled = true;
                    playButton.style.color = 'grey';
                    playButton.style.backgroundColor = 'rgb(204, 204, 204, 0.2)';
                    playButton.style.borderColor = 'rgb(204, 204, 204, 0.2)';  // Optional: visual feedback for disabled state

                // Handle successful play request
                console.log('Playing song:', track.name);
                notifySong(track);

            } catch (error) {
                console.error('Error playing song:', error);
                alert('An error occurred while trying to play the song');
            }
        }

        async function notifySong(track) {
            try {

                const notifyRequest = {
                    song: track.name,
                    artist: track.artists.map(artist => artist.name),
                    album: track.image
                };

                const response = await fetch(NOTIFY_API_ENDPOINT, {
                    method: 'POST',
                    credentials: "same-origin",
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(notifyRequest)
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

            } catch (error) {
                console.error('Error playing song:', error);
                alert('An error occurred while trying to notify the song');
            }
        }
        
        function startServiceCheck() {
            let checkInterval;

            // First verify token before starting checks
            const verifyAndStartChecks = async () => {
                
                const token = await getApiToken();
                if (!token) {
                    console.error('No valid API token found');
                    document.getElementById('page').style.display = 'none';
                    document.getElementById('accessDenied').style.display = 'block';
                    document.getElementById('accessDenied').innerHTML = `
                        <h2>Queueing Closed</h2>
                        <p>Sorry, the jukebox is currently disabled. Until next time!</p>
                    `;
                    return;
                }

                
                checkService().catch(error => {
                    if (error.status === 401) {
                        console.error('Authentication failed, stopping service checks');
                        if (checkInterval) {
                            clearInterval(checkInterval);
                        }
                        document.getElementById('page').style.display = 'none';
                        document.getElementById('accessDenied').style.display = 'block';
                        document.getElementById('accessDenied').innerHTML = `
                            <h2>Authentication Error</h2>
                            <p>Failed to authenticate with Home Assistant. Please check your token.</p>
                        `;
                    }
                });
                
                // Then check every 10 seconds
                checkInterval = setInterval(async () => {
                    try {
                        // Verify token before each check
                        const currentToken = await getApiToken();
                        if (!currentToken) {
                            throw { status: 401, message: 'No valid API token' };
                        }
                        
                        const isEnabled = await checkService();
                        const pageElement = document.getElementById('page');
                        const accessDeniedElement = document.getElementById('accessDenied');

                        if (!isEnabled) {
                            pageElement.style.display = 'none';
                            accessDeniedElement.style.display = 'block';
                            document.getElementById('songResults').innerHTML = '';
                            document.getElementById('searchInput').value = '';
                        } else {
                            pageElement.style.display = 'block';
                            accessDeniedElement.style.display = 'none';
                        }
                    } catch (error) {
                        if (error.status === 401) {
                            console.error('Authentication failed, stopping service checks');
                            clearInterval(checkInterval);
                            document.getElementById('page').style.display = 'none';
                            document.getElementById('accessDenied').style.display = 'block';
                            document.getElementById('accessDenied').innerHTML = `
                                <h2>Authentication Error</h2>
                                <p>Failed to authenticate with Home Assistant. Please check your token.</p>
                            `;
                        }
                    }
                }, 10000);
            };

            // Start the verification and check process
            verifyAndStartChecks();
        }

        async function checkService() {
            try {
                const response = await fetch(CHECK_API_ENDPOINT, {
                    method: 'GET',
                    credentials: "same-origin",
                    headers: {
                        'Authorization': `Bearer ${API_TOKEN}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                });

                if (response.status === 401) {
                    const error = new Error('Unauthorized');
                    error.status = 401;
                    throw error;
                }

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const result = await response.json();
                const enabled = result.state;
                const pageElement = document.getElementById('page');
                const accessDeniedElement = document.getElementById('accessDenied');

                if (enabled === 'on') {
                    console.log("app enabled");
                    pageElement.style.display = 'block';
                    accessDeniedElement.style.display = 'none';
                    return true;
                } else {
                    console.log("app disabled");
                    pageElement.style.display = 'none';
                    accessDeniedElement.style.display = 'block';
                    return false;
                }

            } catch (error) {
                console.error('Error checking service:', error);
                throw error; // Re-throw to handle in startServiceCheck
            }
        }
    
        var TxtRotate = function(el, toRotate, period) {
          this.toRotate = toRotate;
          this.el = el;
          this.loopNum = 0;
          this.period = parseInt(period, 10) || 2000;
          this.txt = '';
          this.tick();
          this.isDeleting = false;
        };
        
        TxtRotate.prototype.tick = function() {
          var i = this.loopNum % this.toRotate.length;
          var fullTxt = this.toRotate[i];
        
          if (this.isDeleting) {
            this.txt = fullTxt.substring(0, this.txt.length - 1);
          } else {
            this.txt = fullTxt.substring(0, this.txt.length + 1);
          }
        
          this.el.innerHTML = '<span class="wrap">'+this.txt+'</span>';
        
          var that = this;
          var delta = 200 - Math.random() * 100;
        
          if (this.isDeleting) { delta /= 2; }
        
          if (!this.isDeleting && this.txt === fullTxt) {
            delta = this.period;
            this.isDeleting = true;
          } else if (this.isDeleting && this.txt === '') {
            this.isDeleting = false;
            this.loopNum++;
            delta = 500;
          }
        
          setTimeout(function() {
            that.tick();
          }, delta);
        };

        function generateQRCode() {
            const qrContainer = document.getElementById('qrcode');
            if (!qrContainer) return;

            // Clear any existing QR code
            qrContainer.innerHTML = '';

            // Create QR code
            new QRCode(qrContainer, {
                text: window.location.href,
                width: 200,
                height: 200,
                colorDark: "#ffffff",
                colorLight: "#00000000", // Transparent background
                correctLevel: QRCode.CorrectLevel.H
            });

            // Add label below QR code
            const label = document.createElement('div');
            label.style.color = '#fff';
            label.style.marginTop = '10px';
            label.style.fontSize = '0.9em';
            label.textContent = 'Share and join the jukebox!';
            qrContainer.appendChild(label);
        }
        
        window.onload = function() {
          var elements = document.getElementsByClassName('txt-rotate');
          for (var i=0; i<elements.length; i++) {
            var toRotate = elements[i].getAttribute('data-rotate');
            var period = elements[i].getAttribute('data-period');
            if (toRotate) {
              new TxtRotate(elements[i], JSON.parse(toRotate), period);
            }
          }
          // INJECT CSS
          var css = document.createElement("style");
          css.type = "text/css";
          css.innerHTML = ".txt-rotate > .wrap { border-right: 0.08em solid #666 }";
          document.body.appendChild(css);
        
          // Generate QR code
          generateQRCode();
        };
        
        FocusOnInput();
        document.getElementById("searchInput").focus();
    </script>
</body>

</html>